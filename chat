import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# ------------------ CONFIG ------------------
CSV_PATH = "your_data.csv"   # <-- change me
BRANDS = [
    'bmw','volkswagen','mercedes-benz ag','volvo','toyota','ford','stellantis','nissan',
    'kia','renault','byd','tesla','mazda','hyundai','polestar','gm','jlr','subaru'
]
# desired columns (we'll use only those present)
DESIRED_NUM_COLS = [
    'Motor_cc', 'CO2_g_per_km', 'Fuel_L_per_100km',
    'Elec_kWh_per_100km', 'Power_kW', 'Price_USD'
]
LOWER_IS_BETTER = {'CO2_g_per_km','Fuel_L_per_100km','Elec_kWh_per_100km','Price_USD'}

# ------------------ LOAD ------------------
df = pd.read_csv(CSV_PATH)
print("DEBUG columns in file:", list(df.columns))

# brand filter (skip if not present)
if 'Bidder_Name' in df.columns:
    df['Bidder_Name'] = df['Bidder_Name'].astype(str).str.strip().str.lower()
    df = df[df['Bidder_Name'].isin(BRANDS)].copy()
else:
    raise ValueError("Column 'Bidder_Name' not found in the file.")

# keep only available numeric columns
avail = [c for c in DESIRED_NUM_COLS if c in df.columns]
missing = [c for c in DESIRED_NUM_COLS if c not in df.columns]
if missing:
    print("⚠️ Missing columns (skipped):", missing)
if not avail:
    raise ValueError("None of the desired numeric columns are present. Add columns or adjust DESIRED_NUM_COLS.")

# convert to numeric safely
for c in avail:
    df[c] = pd.to_numeric(df[c], errors='coerce')

# treat impossible zeros as missing for some fields (only if present)
for c in ('Motor_cc','Power_kW','Fuel_L_per_100km','Price_USD'):
    if c in avail:
        df[c] = df[c].replace(0, pd.NA)

# debug: show counts of bad rows
print("\n=== DEBUG: missing/invalid rows by column ===")
for c in avail:
    n_bad = int(df[c].isna().sum())
    if n_bad:
        print(f"{c}: {n_bad} rows will be dropped")

# drop rows missing ANY of the available numeric cols
df = df.dropna(subset=avail)

# per-brand averages
brand_avg = df.groupby('Bidder_Name', as_index=False)[avail].mean()

# if nothing remains, stop early
if brand_avg.empty:
    raise ValueError("No rows left after cleaning. Check your data quality and filters.")

# min-max normalize helper
def minmax(s: pd.Series) -> pd.Series:
    lo, hi = s.min(), s.max()
    return (s - lo) / (hi - lo + 1e-12)

# build normalized metrics (invert where lower is better)
norm_cols = []
for c in avail:
    ncol = f"{c}_norm"
    brand_avg[ncol] = (1 - minmax(brand_avg[c])) if c in LOWER_IS_BETTER else minmax(brand_avg[c])
    norm_cols.append(ncol)

# score = mean of available normalized metrics
brand_avg['Score'] = brand_avg[norm_cols].mean(axis=1)

# fill NaN (shouldn’t happen now, but safe)
brand_avg['Score'] = brand_avg['Score'].fillna(0)

# rank
brand_avg['Rank'] = brand_avg['Score'].rank(ascending=False, method='min').astype(int)
brand_avg = brand_avg.sort_values(['Rank','Bidder_Name'])

# -------- Tables you asked for --------
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
print("\n=== Segregated Averages + How Score was computed ===")
print(brand_avg.to_string(index=False))

# -------- Plot Top 10 (only if we have scores) --------
top10 = brand_avg.head(10)
if not top10.empty:
    plt.figure(figsize=(10,6))
    sns.barplot(data=top10, x='Score', y='Bidder_Name', palette='viridis')
    for i, v in enumerate(top10['Score']):
        plt.text(float(v)+0.005, i, f"{v*100:.2f}%", va='center', fontsize=10, fontweight='bold')
    plt.title('Top 10 Brands with Highest Customer Value')
    plt.xlabel('Score')
    plt.ylabel('Brand')
    plt.tight_layout()
    plt.show()
else:
    print("No data to plot.")
